<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PeerJS - 4-Person Chat (Everyone Hosts)</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        #messages {
            border: 1px solid #ccc;
            padding: 10px;
            width: 400px;
            height: 300px;
            overflow-y: scroll;
            margin-bottom: 10px;
        }

        input {
            padding: 10px;
            width: 300px;
        }

        button {
            padding: 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
        }

        button:hover {
            background-color: #45a049;
        }

        .message {
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <h1>PeerJS 4-Person Dynamic Chat (Everyone Hosts)</h1>
    <div id="messages"></div>
    <input type="text" id="messageInput" placeholder="Type a message...">
    <button id="sendMessageButton">Send</button>

    <script src="https://cdn.peerjs.com/1.3.2/peerjs.min.js"></script>
    <script>
        const peer = new Peer();
        const connections = [];
        const messageBox = document.getElementById('messages');
        const messageInput = document.getElementById('messageInput');
        const sendMessageButton = document.getElementById('sendMessageButton');

        let peerIDCounter = 1;  // Start from peerID1
        const assignedPeerIDs = [];  // Array to keep track of assigned peer IDs
        const maxPeers = 4;  // Maximum number of connected peers at any time
        let currentPeers = [];  // Keeps track of the current 4 connected peers

        function displayMessage(message, sender) {
            const msgElement = document.createElement('div');
            msgElement.classList.add('message');
            msgElement.textContent = `${sender}: ${message}`;
            messageBox.appendChild(msgElement);
            messageBox.scrollTop = messageBox.scrollHeight;
        }

        function getNextPeerID() {
            let newPeerID = `peerID${peerIDCounter}`;
            while (assignedPeerIDs.includes(newPeerID)) {
                peerIDCounter++;
                newPeerID = `peerID${peerIDCounter}`;
            }
            assignedPeerIDs.push(newPeerID);
            peerIDCounter++;  // Increment counter for the next peer
            return newPeerID;
        }

        function connectToAllPeers() {
            const currentPeerIDs = currentPeers.map(peer => peer.peerID);
            currentPeers.forEach(peer => {
                peer.conn.send({ message: 'You are now connected to the group!', peers: currentPeerIDs });
            });
        }

        peer.on('connection', (conn) => {
            connections.push(conn);
            conn.on('data', (data) => {
                displayMessage(data.message, conn.peer);
            });
            conn.on('close', () => {
                const index = connections.indexOf(conn);
                if (index !== -1) {
                    connections.splice(index, 1);
                }
                displayMessage('A peer has disconnected.', conn.peer);
            });
        });

        peer.on('open', (id) => {
            const newPeerID = getNextPeerID();  // Generate the next available peer ID
            console.log(`Your peer ID: ${newPeerID}`);

            // If we haven't reached 4 peers yet, try connecting to others
            if (currentPeers.length < maxPeers) {
                currentPeers.push({ peerID: newPeerID, conn: peer });
                console.log(`${newPeerID} joined the group`);

                if (currentPeers.length === maxPeers) {
                    console.log('Session is full, establishing connections between peers.');
                    connectToAllPeers(); // Share peer list with all peers
                }
            } else {
                // If the session is full, disconnect and notify the user
                displayMessage('The session is full. Please try again later.', 'Server');
                peer.disconnect();
            }
        });

        sendMessageButton.addEventListener('click', () => {
            const message = messageInput.value;
            if (message.trim()) {
                connections.forEach(conn => {
                    conn.send({ message: message });
                });
                displayMessage(message, 'You');
                messageInput.value = '';
            }
        });

        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessageButton.click();
            }
        });

        // Peer-to-peer connection setup
        peer.on('open', (id) => {
            setInterval(() => {
                // Attempt to connect to other peers if there are fewer than 4 peers
                if (currentPeers.length < maxPeers) {
                    // Dynamically try to connect to available peers
                    const otherPeers = currentPeers.filter(peer => peer.peerID !== id);
                    otherPeers.forEach(peer => {
                        connectToPeer(peer.peerID);
                    });
                }
            }, 5000);  // Check for new peers every 5 seconds
        });

        function connectToPeer(peerId) {
            const conn = peer.connect(peerId);
            conn.on('open', () => {
                console.log(`Connected to peer: ${peerId}`);
            });
            conn.on('data', (data) => {
                displayMessage(data.message, peerId);
            });
            conn.on('close', () => {
                const index = currentPeers.findIndex(peer => peer.peerID === peerId);
                if (index !== -1) {
                    currentPeers.splice(index, 1);
                }
                displayMessage(`${peerId} has disconnected.`, 'Server');
            });
        }

    </script>
</body>
</html>
