<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PeerJS Scalable Network</title>
    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js"></script>
</head>
<body>
    <script>
        let peer;
        const maxConnections = 3;
        const connections = new Map();
        let peeridno = Math.floor(Math.random() * 10000);

        function initializePeer() {
            const peerId = `peer${peeridno}`;
            peer = new Peer(peerId, { debug: 2 });

            peer.on('open', id => {
                console.log(`Peer started with ID: ${id}`);
                findPeers(id);
            });

            peer.on('connection', conn => {
                if (connections.has(conn.peer) || connections.size >= maxConnections) {
                    conn.close();
                    return;
                }
                setupConnection(conn);
            });

            peer.on('error', err => {
                console.error(`Peer error: ${err.type}`);
                if (err.type === 'unavailable-id') {
                    peeridno++;
                    initializePeer();
                }
            });
        }

        function findPeers(currentPeerId) {
            let targetPeerId = `peer${peeridno - 1}`;
            if (targetPeerId === currentPeerId) return;

            const conn = peer.connect(targetPeerId);
            setupConnection(conn);

            conn.on('error', () => {
                console.log(`Failed to connect to ${targetPeerId}, trying next.`);
                findPeers(currentPeerId);
            });
        }

        function setupConnection(conn) {
            conn.on('open', () => {
                connections.set(conn.peer, conn);
                console.log(`Connected to ${conn.peer}`);
                propagateConnections();

                conn.send({
                    type: 'initial-connections',
                    peers: Array.from(connections.keys())
                });
            });

            conn.on('data', handleIncomingData);
            conn.on('close', () => {
                connections.delete(conn.peer);
                console.log(`${conn.peer} disconnected.`);
                healNetwork();
            });
        }

        function handleIncomingData(data) {
            if (data.type === 'initial-connections') {
                data.peers.forEach(peerId => {
                    if (!connections.has(peerId) && peerId !== peer.id && connections.size < maxConnections) {
                        const conn = peer.connect(peerId);
                        setupConnection(conn);
                    }
                });
            }
        }

        function propagateConnections() {
            const connectedPeers = Array.from(connections.keys());
            connections.forEach(conn => {
                conn.send({ type: 'initial-connections', peers: connectedPeers });
            });
        }

        function healNetwork() {
            if (connections.size < maxConnections) {
                console.log('Healing network...');
                findPeers(peer.id);
            }
        }

        initializePeer();
    </script>
</body>
</html>
